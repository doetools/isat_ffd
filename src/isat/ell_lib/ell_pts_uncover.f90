!---------------------------------------------------------------------!
! OWNER: Ithaca Combustion Enterprise, LLC                            !
! COPYRIGHT: Â© 2012, Ithaca Combustion Enterprise, LLC                !
! LICENSE: BSD 3-Clause License (The complete text of the license can !
!  be found in the `LICENSE-ICE.txt' file included in the ISAT-CK7    !
!  source directory.)                                                 !
!---------------------------------------------------------------------!

subroutine ell_pts_uncover( n, c, r_max, theta, npts, p, gg, phi, r_min )

!  Given:
!  1/ npts points p in n-space
!  2/ a center position c and a radius r_max
!  3/ a parameter  theta  0< theta <=1

!  Determine an ellipsoid E which:
!  1/ is centered at c
!  2/ has principal semi-axes no larger than r_max
!  3/ does not cover any of the given points p
!  4/ is as "large" as possible.

!  E is given by { x | norm(G^T * (x-c) ) <=1 ),  where G is an n x n lower 
!  triangular matrix.  The array gg contains the matrix G in packed format.

!  The parameter theta ( 0 < theta <= 1 ) controls the shape of the ellipsoid
!  and the conditioning of the procedure.

!  In the first phase of the algorithm described below, a provisional ellipsoid,
!  E_n, is determined.  E is then obtained, by shrinking E_n by a factor phi, 
!  so that no points are covered by E.  phi satisfies  theta <= phi <= 1.

!  S.B. Pope  6/30/06

!  Method:
!  There are n stages, in each of which a principal axis is determined.
!  The ellipsoid generated by stage k is denoted by E_k.
!  The length of the k-th principal semi-axis of E_k is r(k), and is determined
!  in the k-th stage.  The principal axes of E_k are r(j), for 1<= j <= k,
!  and r(k) for k <= j <= n.

!  The points are either "included", "partially excluded" or "excluded",
!  as described below.  Initially, all points are "included."

!  The displacementa of the points from c are given by y(1:n,1:npts), which
!  are the coordinates in an orthonormal basis which evolves (by Householder 
!  reflections).  After stage k, the first k basis vectors are the principal axes.

!  At the end of the k-th stage, point j is covered by E_k if  h(j) <= 1,
!  where  h(j)  is defined by:
!    h(j) = sum_{i=1:n} (y(i,j)/r(i))^2
!  This can be decomposed as:
!    h(j) = f(j) + g(j)/r(k)^2,  where
!    f(j) = sum_{i<k} (y(i,j)/r(i))^2  and   g(j) = sum_{i>=k}(y(i,j))^2.

!  In the k-th stage, r(k) is taken to be as large as possible, such that  h(j) 
!  is greater than (or equal to) one for all included points, and such that r(k) 
!  is no greater that r_max.

!  If, at some stage and for some point j, f(j) exceeds unity, then that 
!  point cannot be covered by E_n, regardless of how the remaining principal
!  axes are chose.  Such points are therefore "excluded" from further consideration.

!  Points with f(j) > theta^2 (for  0 < theta <= 1) are "partially excluded."  
!  This means that they are not used to decide the principal axes.

!  The ellipsoid E_n generated at the end of the n-th stage has pricipal axes less
!  than or equal to r_max.  It does not cover any excluded points, but it may 
!  cover other points.  E is then obtained by shrinking E_n by a determined factor
!  phi  (theta <= phi <= 1) such that E covers none of the points.

implicit none

integer, parameter      :: k_dp = kind(1.d0)

integer, intent(in)     :: n      ! dimensionality of the space
real(k_dp), intent(in)  :: c(n)   ! center of the ellipsoid E
real(k_dp), intent(in)  :: r_max  ! upper bound on principal semi-axes
real(k_dp), intent(in)  :: theta  ! control parameter
integer, intent(in)     :: npts   ! number of given points
real(k_dp), intent(in)  :: p(1:n,1:npts)   !  given points
real(k_dp), intent(out) :: gg((n*(n+1))/2) !  packed Cholesky matrix for E
real(k_dp), intent(out) :: phi    !  factor by which E_n is shrunk
real(k_dp), intent(out) :: r_min  !  smallest principal semi-axis of E

real(k_dp), parameter   :: shrink = 1.d-6  ! shrink to uncover points on boundary

integer    :: indicator(npts)  ! = 0, 1, 2 for included, partially excluded, 
!                                  and excluded points
integer    :: j, k, kk, jmin
real(k_dp) :: f(npts), y(n,npts), g, r_max_sq, rsq, rsq_min, u(n,n), &
              r(n), v(n), w(n), beta, theta_sq

!---------  check input

   if( n < 1  .or.  npts < 0  .or.  r_max <= 0.d0  .or.  &
       theta <= 0.d0  .or.  theta > 1.d0 ) then
	   write(0,*) 'ell_pts_uncover: bad inpt, n, r_max, theta, npts = ', &
	              n, r_max, theta, npts
	   stop
   endif  
!---------  initialization

   indicator = 0      !  all points are initially included
   r         = r_max  !  provisionally set E to ball of radius r_max
   f         = 0.d0
   u         = 0.d0
   r_max_sq  = r_max**2
   theta_sq  = theta**2
   phi       = 1.d0

   do k = 1, n  !  set canonical basis, i.e., U = I
      u(k,k) = 1.d0
   end do

   do j=1,npts  !  set displacements of points from c
      y(1:n,j) = p(1:n,j) - c(1:n)
   end do

!--------  loop over stages

   stages: do k = 1, n

      jmin = 0
	  rsq_min = r_max_sq

!  find the smallest g(j)
      do j = 1, npts
	     if( indicator(j) > 0 ) cycle  !  consider only included points
		 g    = sum( y(k:n,j)*y(k:n,j) )
		 if( g < rsq_min*(1.d0-f(j) ) ) then
		    jmin    = j
			rsq_min = g / ( 1.d0 - f(j) )
		 endif
      end do

	  if( jmin == 0 ) exit  stages  ! remaining principal semi-axis = r_max
	     
      r(k) = sqrt( rsq_min ) !  principal semi-axis

	  !  Householder transformation so that, after transformation,
	  !  y(k:n,jmin) = [ r(k) 0 0 ... 0]'
	  !  Transform all included points

      v  = 0.d0
	  kk = n+1-k
	  call ell_house( kk, y(k:n,jmin), v(k:n), beta )

!  update orthogonal matrix U: post-multiply by H = I - beta * v * v^T

      w = beta * matmul( u(:,k:n), v(k:n) )
	  do j = k, n
	     u(:,j) = u(:,j) - w(:) * v(j)
	  end do

      if( k == n ) exit stages  !  skip f update on last stage

!  loop over points to update f and exclude
      do j = 1, npts
	     if( indicator(j) > 0 ) cycle  !  consider only included points

!  transform points to new basis
         y(k:n,j) = y(k:n,j) - beta * v(k:n) * sum( v(k:n)*y(k:n,j) )

!  update f and exclude points if so indicated
         f(j) = f(j) + (y(k,j)/r(k))**2

		 if( f(j) >= 1.d0 ) then
		    indicator(j) = 2  !  fully excluded
		 elseif( f(j) > theta_sq ) then
		    indicator(j) = 1  !  partially exclude
		 endif

      end do

   end do  stages !  end of loop over stages

!  form first estimate of E
   r_min = r(1)

   do k = 1, n
	  r(k) = 1.d0 / r(k)
   end do

   call ell_eig2chol( n, u, r, gg )

!  scale gg to ensure that all included and partially-excluded points are not 
!    covered

   rsq_min = huge(0.d0)

   kk = 0
   do j = 1, npts
      if( indicator(j) == 2 ) cycle  !  do not consider excluded points
	  kk      = kk + 1
      v       = p(:,j)-c   
      call dtpmv( 'L', 'T', 'N', n, gg, v, 1 )  !  yp = G^T * [p-c]
      rsq     = sum(v*v) 
	  rsq_min = min( rsq, rsq_min )
   end do

   if( kk > 0 .and.  rsq_min < 1.d0 ) then ! shrink E by phi to uncover all points
      phi   = sqrt(rsq_min)
	  phi   = min( phi, 1.d0/(1.d0+shrink) )
	  r_min = r_min * phi
      gg    = gg  / phi 

   else  ! shrink E slightly to uncover points on boundary
      gg    = gg * (1.d0+shrink)
      r_min = r_min / (1.d0+shrink)
   endif

   return

end subroutine ell_pts_uncover